# -*- coding: utf-8 -*-
"""
Created on Tue Feb 25 09:37:31 2025
v2.0 (04.2025)

@author: Quirin Möller (ge26deb)


Reads an ASCII file generated by WinDETA

TODO neues Beispiel
example usage:
from novo_importer import read_novo, parameter_names
    
# filepath erstellen:
import pathlib # Plattform unabhängig
messfolder = pathlib.PurePath('I:/BA_Moeller/03_Messergebnisse/032_Messergebnisse/')
messfile = pathlib.PurePath('Novocontrol/20250220/20250220-P6_22-50-70-90DEG_01.TXT')
messpath = messfolder.joinpath(messfile)

df, einheiten = read_novo(messpath)
"""

# TODO namen vereinheitlichen (alles einfach nur name)

import pandas as pd
import re
import pathlib
from itertools import repeat
import basicE as be

class Measurement:
    def __init__(self, filepath=None, measurement_name=None):
        self.df = pd.DataFrame()
        self.einheiten = None
        self.metadata = {}
        self.name = None
        if filepath:
            if not isinstance(filepath, pathlib.WindowsPath | pathlib.PosixPath): # relevant? wenn, dann in import verschieben
                self.filepath = pathlib.PurePath(filepath)
            else:
                self.filepath = filepath
            self.df, self.einheiten, self.metadata = read_novo(self.filepath)
            if measurement_name:
                self.name = measurement_name
            else:
                self.name = self.filepath.stem

    def plot(self, parameter_to_plot, ax, color=None, x="Freq.", label=None, **kwargs):
        # color = "#3070b3" # TUM Blau
        if label is None:
            label = self.name
        self.df.plot(x=x, y=parameter_to_plot, ax=ax, label=label, color=color, **kwargs)

    def mean(self, ignore_negatives=False):
        if ignore_negatives:
            tdf = self.df[self.df >= 0]
        else:
            tdf = self.df.copy()
        series_mean = tdf.mean()
        return series_mean



class MeasurementGroup():
    # TODO allgemeinen group Parameter festlegen (normal Freq.), der überall als Index verwendet wird

    def __init__(self, measurements=None):
        self._empty = True
        self.measurements = {}
        self.group_Name = None
        self.plot_kwargs = {}
        if measurements:
            if isinstance(measurements, Measurement): # if its just a single measurement
                self.measurements[measurements.name] = [measurements]
            else:
                for m in measurements:
                    self.measurements[m.name] = m
            self._empty = False

    @classmethod
    def from_files(cls, basepath, filenames, measurement_names=None):
        msl = []
        if measurement_names is None:
            if isinstance(filenames, dict):
                for name, filename in filenames.items():
                    msl.append(Measurement(basepath.joinpath(filename), name))
            else:
                for filename in filenames:
                    msl.append(Measurement(basepath.joinpath(filename)))
        elif len(measurement_names) == len(filenames):
            for filename, name in zip(filenames, measurement_names):
                msl.append(Measurement(basepath.joinpath(filename), name))
        else:
            raise ValueError("Number of measurement names does not match number of filenames")
        return cls(msl)


    def __len__(self):
        return len(self.measurements)
    
    def __getitem__(self, key):
        if isinstance(key, int):
            return list(self.measurements.values())[key]
        return self.measurements[key]
    
    def __iter__(self):
        return iter(self.measurements.values())
    
    def __setitem__(self, measurement:Measurement):
        # FIXME macht so kein Sinn, braucht wahrscheinlich nen Index input
        self.measurements[measurement.name] = measurement
        self._empty = False

    def __delitem__(self, key):
        if key in self.measurements or isinstance(key, int):
            if isinstance(key, int):
                key = list(self.measurements.keys())[key]
            del self.measurements[key]
            if len(self.measurements) == 0:
                self._empty = True
        else:
            raise KeyError(f"Key '{key}' not found.")
    
    def append_measurement(self, measurement, name=None):
        # TODO check if compatible
        if isinstance(measurement, Measurement):
            if name is not None:
                measurement.name = name
            self.measurements[measurement.name] = measurement
        else:
            m = Measurement(measurement, name)
            if m.name in self.measurements:
                print(f"Measurement {m.name} already exists. Overwriting.")
            self.measurements[m.name] = m
        self._empty = False

    @property
    def einheiten(self):
        return self[0].einheiten
    
    # TODO: add column options for ignore_negatives
    # df_gesamt.iloc[:, 1:] = df_gesamt.iloc[:, 1:].where((df_gesamt.iloc[:, 1:] >= 0) | df_gesamt.columns.to_series().eq("Sig.''"))
    def mean(self, groupby="Freq.", ignore_negatives=False):
        df_all = pd.concat([m.df for m in self])
        if ignore_negatives:
            df_all = df_all[df_all >= 0]
        df_mean = df_all.groupby(by=groupby).mean()
        mean_measurement = Measurement()
        mean_measurement.df = df_mean.reset_index()
        mean_measurement.einheiten = self[0].einheiten
        mean_measurement.metadata = self[0].metadata
        mean_measurement.name = f"{self.group_Name} mean"
        if "Thickness" in mean_measurement.metadata:
            mean_measurement.metadata["Thickness"] = sum([m.metadata["Thickness"] for m in self]) / len(self)
        return mean_measurement
    
    def plot_singles(self, parameter_to_plot, ax, colors=None, x="Freq.", labels=None, **kwargs):
        if colors is None or isinstance(colors, str):
            colors = repeat(colors)
        elif len(colors) != len(self) and isinstance(colors, list):
            raise ValueError("Number of colors does not match number of measurements")
        elif not all(isinstance(c, str) for c in colors):
            raise TypeError("Colors must be a list of strings or a single string")
        if labels is None:
            labels = repeat(None)
        elif len(labels) != len(self):
            raise ValueError("Number of labels does not match number of measurements")
        for m, color, label in zip(self, colors, labels):
            m.plot(parameter_to_plot, ax, color=color, x=x, label=label, **kwargs, **self.plot_kwargs)

    def plot_mean_bounds(self, parameter_to_plot, ax, color="#3070b3", x="Freq.", label=None, ignore_negatives=False):
        if label is None:
            label = self.group_Name
        mean_measurement = self.mean(x, ignore_negatives=ignore_negatives)
        mean_measurement.plot(parameter_to_plot, ax, color=color, x=x, label=label)
        df_all = pd.concat([m.df for m in self])
        if ignore_negatives:
            df_all = df_all[df_all >= 0]
        maxes = df_all.groupby(by=x)[parameter_to_plot].max()
        mins = df_all.groupby(by=x)[parameter_to_plot].min()
        ax.plot(maxes.index, maxes, color=color, lw=0.8)
        ax.plot(mins.index, mins, color=color, lw=0.8)
        ax.fill_between(maxes.index, maxes, mins, color=color, alpha=.2)

    # the mean of the mean deviation
    @property
    def mean_deviation(self):
        mean_deviation_series = self.mean_deviation_series
        mean_deviation = mean_deviation_series.mean()
        return mean_deviation

    # TODO self.df nur über getter und setter zugänglich machen
    # https://stackoverflow.com/questions/2627002/whats-the-pythonic-way-to-use-getters-and-setters

    # the mean deviation over the frequqency (or other parameter TODO)
    @property
    def mean_deviation_series(self):
        df_mean = self.mean(ignore_negatives=True).df.copy()
        df_mean.sort_values(by="Freq.", inplace=True)
        df_mean.set_index("Freq.", inplace=True)
        diffs = []
        for i in self:
            idf = i.df.copy()
            idf.sort_values(by="Freq.", inplace=True)
            idf.set_index("Freq.", inplace=True)
            x = df_mean.sub(idf).div(df_mean).abs()
            diffs.append(x)
        diffs_sum = sum(diffs)
        diffs_sum = diffs_sum.div(len(diffs))
        # TODO ähnlich wie bei mean mit concat, groupby und mean
        return diffs_sum


        



class MeasurementSeries(MeasurementGroup):
    def __init__(self, filepath, free_variable, name=None):
        self.measurement = Measurement(filepath, measurement_name=name)
        groups = self.measurement.df.groupby(by=free_variable)
        dfd = {label: group for label, group in groups}
        msl = []
        for label, df in dfd.items():
            m = Measurement()
            m.einheiten = self.measurement.einheiten
            m.metadata = self.measurement.metadata
            m.df = df.sort_values(by="Freq.").reset_index(drop=True)
            m.name = f"{self.measurement.name}_{label}"
            msl.append(m)
        super().__init__(msl)
        self.free_variable = free_variable
        self.group_Name = self.measurement.name
        

# parse Parameters and Units from header
def _parse_header_info(headers):
    def remove_units(header):
        return re.sub(r'\[.*?\]', '', header).strip()

    def extract_units(header):
        match = re.search(r'\[(.*?)\]', header)
        return match.group(1) if match else ''

    parameter = [remove_units(header) for header in headers]

    units = [extract_units(header) for header in headers]

    return parameter, units

# read metadata from file
def _parse_metadata(frontmatter):
    metadata = {}
    metadata["Sample"] = frontmatter[0].split(",")[0].strip()
    metadata["Date"] = frontmatter[0].split(",")[1].strip()
    metadata["Time"] = frontmatter[0].split(",")[2].strip()
    metadata["Diameter"] = float(frontmatter[1].split(" ")[1]) # mm
    thickness_match = re.search(r'Thickness\[mm\]\s+([\d\.e\+\-]+)', frontmatter[1])
    metadata["Thickness"] = float(thickness_match.group(1)) if thickness_match else None # mm
    spacer_capacity_match = re.search(r'Spacer Capacity\[pF\]\s+([\d\.e\+\-]+)', frontmatter[1])
    metadata["Spacer Capacity"] = float(spacer_capacity_match.group(1)) if spacer_capacity_match else None # pF
    spacer_area_match = re.search(r'Spacer Area\[mm\^2\]\s+([\d\.e\+\-]+)', frontmatter[1])
    metadata["Spacer Area"] = float(spacer_area_match.group(1)) if spacer_area_match else None # mm^2
    metadata["Edge Correction"] = True if "Edge Correction On" in frontmatter[1] else False
    if metadata["Edge Correction"]:
        electrode_thickness_match = re.search(r'Electrode Thickness\[mm\]\s+([\d\.e\+\-]+)', frontmatter[1])
        metadata["Electrode Thickness"] = float(electrode_thickness_match.group(1)) if electrode_thickness_match else None # mm
    return metadata


# read file
def read_novo(filepath):
    with open(filepath, 'r') as file:
        data = file.readlines()
    
    # extract header, metadata, units
    header = list(map(str.strip, data[3].strip().split("\t"))) # remove whitespaces
    data_lines = data[4:]    
    frontmatter = data[:3]
    metadata = _parse_metadata(frontmatter)
    
    parameters, units = _parse_header_info(header)
    einheiten = dict(zip(parameters, units))
    
    
    # Save data in dictionary
    data_dict = {key: [] for key in parameters}
    for line in data_lines:
        values = line.strip().split()
        for key, value in zip(parameters, values):
            data_dict[key].append(float(value))
    
    # convert to DataFrame
    return pd.DataFrame(data_dict), einheiten, metadata

# get metadate from filename
def _parse_filename(filepath):
    filename = filepath.name
    metadata = {}
    metadata["Date"] = filename.split("-")[0]
    metadata["Sample"] = filename.split("_")[0][9:]
    metadata["Temperature"] = filename.split("_")[1].split("DEG")[0]
    metadata["m_number"] = filename.split("_")[-1].split(".")[0]
    return metadata

def stacked(measurements):
    m_stacked = Measurement()
    if len(measurements) == 0:
        raise ValueError("No measurements to stack")
    if not all(m.df.shape == measurements[0].df.shape for m in measurements):
        raise ValueError("All measurements must have the same dimensions")
    if not all(m.einheiten == measurements[0].einheiten for m in measurements):
        raise ValueError("All measurements must have the same einheiten")
    # init m_stacked.df with the index and columns of the first measurement but no values
    m_stacked.df = pd.DataFrame(index=measurements[0].df.index, columns=measurements[0].df.columns)
    m_stacked.einheiten = measurements[0].einheiten
    # concat all the Sample names for the metadata
    m_stacked.metadata['Sample'] =  '+'.join([m.metadata['Sample'] for m in measurements])
    # accumulate all thicknesses
    m_stacked.metadata['Thickness'] = sum([m.metadata['Thickness'] for m in measurements])

    for m in measurements:
        m.df = m.df.sort_values(by="Freq.").reset_index(drop=True)
    
    m_stacked.df['Freq.'] = measurements[0].df['Freq.']
    m_stacked.df['|Eps|'] = be.permittivity_series([m.df['|Eps|'] for m in measurements], [m.metadata['Thickness'] for m in measurements])
    m_stacked.df["Eps'"] = be.permittivity_series([m.df["Eps'"] for m in measurements], [m.metadata['Thickness'] for m in measurements])
    m_stacked.df["Eps''"] = be.permittivity_series([m.df["Eps''"] for m in measurements], [m.metadata['Thickness'] for m in measurements])
    m_stacked.df['|Sig|'] = be.leitfaehigkeit_reihe([m.df['|Sig|'] for m in measurements], [m.metadata['Thickness'] for m in measurements])
    m_stacked.df["Sig'"] = be.leitfaehigkeit_reihe([m.df["Sig'"] for m in measurements], [m.metadata['Thickness'] for m in measurements])
    m_stacked.df["Sig''"] = be.leitfaehigkeit_reihe([m.df["Sig''"] for m in measurements], [m.metadata['Thickness'] for m in measurements])

    return m_stacked

    
parameter_names = {"Freq.": "Frequenz",
                    "Temp.": "Temperatur",
                    "Eps'": "Eps'",
                    "Eps''": "Eps''",
                    "|Eps|": "Permittivität",
                    "Sig'": "Leitfähigkeit Realteil",
                    "Sig''": "Sig''",
                    "|Sig|": "Leitfähigkeit",
                    "Tan(Delta)": "Verlustfaktor Tan(δ)",
                    "M Temp": "gemessene Temperatur"}

if __name__ == "main":
    print("novo import tool v2.0")