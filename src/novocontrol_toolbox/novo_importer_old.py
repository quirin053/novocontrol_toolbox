# -*- coding: utf-8 -*-
"""
Created on Tue Feb 25 09:37:31 2025
v1.1 (03.2025)

@author: ge26deb


Reads an ASCII file generated by WinDETA and returns a DataFrame
and a dictionary with the corresponding units

TODO eigene Klasse

example usage:
from novo_importer import read_novo, parameter_names
    
# filepath erstellen:
import pathlib # Plattform unabhängig
messfolder = pathlib.PurePath('I:/BA_Moeller/03_Messergebnisse/032_Messergebnisse/')
messfile = pathlib.PurePath('Novocontrol/20250220/20250220-P6_22-50-70-90DEG_01.TXT')
messpath = messfolder.joinpath(messfile)

df, einheiten = read_novo(messpath)
"""

import pandas as pd
import re


# Paramter und Einheiten aufteilen
def _generate_lists(headers):
    # Funktion zum Entfernen der Einheiten aus den Spaltenüberschriften
    def remove_units(header):
        return re.sub(r'\[.*?\]', '', header).strip()

    # Funktion zum Extrahieren der Einheiten aus den Spaltenüberschriften
    def extract_units(header):
        match = re.search(r'\[(.*?)\]', header)
        return match.group(1) if match else ''

    # Erstellen der 'parameter'-Liste
    parameter = [remove_units(header) for header in headers]

    # Erstellen der 'units'-Liste
    units = [extract_units(header) for header in headers]

    return parameter, units

# read metadata from file
def _parse_metadata(frontmatter):
    metadata = {}
    metadata["Sample"] = frontmatter[0].split(",")[0].strip()
    metadata["Date"] = frontmatter[0].split(",")[1].strip()
    metadata["Time"] = frontmatter[0].split(",")[2].strip()
    metadata["Diameter"] = float(frontmatter[1].split(" ")[1]) # mm
    thickness_match = re.search(r'Thickness\[mm\]\s+([\d\.e\+\-]+)', frontmatter[1])
    metadata["Thickness"] = float(thickness_match.group(1)) if thickness_match else None # mm
    spacer_capacity_match = re.search(r'Spacer Capacity\[pF\]\s+([\d\.e\+\-]+)', frontmatter[1])
    metadata["Spacer Capacity"] = float(spacer_capacity_match.group(1)) if spacer_capacity_match else None # pF
    spacer_area_match = re.search(r'Spacer Area\[mm\^2\]\s+([\d\.e\+\-]+)', frontmatter[1])
    metadata["Spacer Area"] = float(spacer_area_match.group(1)) if spacer_area_match else None # mm^2
    metadata["Edge Correction"] = True if "Edge Correction On" in frontmatter[1] else False
    if metadata["Edge Correction"]:
        electrode_thickness_match = re.search(r'Electrode Thickness\[mm\]\s+([\d\.e\+\-]+)', frontmatter[1])
        metadata["Electrode Thickness"] = float(electrode_thickness_match.group(1)) if electrode_thickness_match else None # mm
    return metadata


# read file
def read_novo(filepath):
    with open(filepath, 'r') as file:
        data = file.readlines()
    
    # extract header, metadata, units
    header = list(map(str.strip, data[3].strip().split("\t"))) # remove whitespaces
    data_lines = data[4:]    
    frontmatter = data[:3]
    metadata = _parse_metadata(frontmatter)
    
    parameters, units = _generate_lists(header)
    einheiten = dict(zip(parameters, units))
    
    
    # Save data in dictionary
    data_dict = {key: [] for key in parameters}
    for line in data_lines:
        values = line.strip().split()
        for key, value in zip(parameters, values):
            data_dict[key].append(float(value))
    
    # convert to DataFrame
    return pd.DataFrame(data_dict), einheiten, metadata

    
parameter_names = {"Freq.": "Frequenz",
                   "Temp.": "Temperatur",
                   "Eps'": "Eps'",
                   "Eps''": "Eps''",
                   "|Eps|": "Permittivität",
                   "Sig'": "Sig'",
                   "Sig''": "Sig''",
                   "|Sig|": "Leitfähigkeit",
                   "Tan(Delta)": "Verlustfaktor Tan(δ)",
                   "M Temp": "gemessene Temperatur"}

